# Advent of FPGA 2025

Day 4 of the Advent of Code implemented in Hardcaml, running on a ZedBoard (Rev. B).

## Overview

This repository contains my submission for [Day
4](https://adventofcode.com/2025/day/4) of Advent of Code written in Hardcaml.
As this is my first foray into the world of FPGAs, the code is rather spaghetti
and suboptimal. I'll attempt to improve on this project if I ever find the time
and motivation to do so.

I chose to tackle Day 4 as it reminded me of Conway's Game of Life, which just
so happened to have a nice FPGA
[implementation](https://github.com/hrvach/Life_MiSTer) and writeup.

The repository is split into the following folders:

- `bin/` - Used to host `generate.ml`, which generates the actual Verilog module
- `src/` - Source code for the logic to solve the challenge, as well as an AXI wrapper
- `test/` - Unit test with Cyclesim to ensure that the circuit works
- `verilog/` - The code generated by `generate.ml`
- `xilinx/` - The additional files I had to write in Vivado for it to run on an actual FPGA

The logic to interact with the board is kind of scuffed. It's driven by a
custom AXI IP that uses the ARM chip on the ZedBoard to load the map data into
the FPGA, waits for its completion, and the ARM chip sends the data to the host
computer via UART.

## Setup Instructions

### Running the Simulation

Follow the setup instructions to get Hardcaml onto your system
[here](https://github.com/janestreet/hardcaml_template_project/tree/with-extensions).

To get started, clone this repository locally and run `dune build` to get
everything built.

To actually see the logic working, head into the `test/test_aoc_solver.ml` and
modify the `Config` module, as well as the `data` variable in the
`expect_test`.

Here's how to modify the `Config` module.

```ocaml
module Config = struct
  module Data = Data

  let log_size = 7 (* Set this to `ceil(log_2(width * height))` *)
  let width = 10   (* Width of the input map *)
  let height = 10  (* Height of the input map *)
end
```

### Exporting to an FPGA

This step is more complicated and I'm too lazy to create a `Makefile` to
automatically setup and synthesise to the board. As such, one would need to
create a Vivado project, as well as a custom AXI IP.

First, head into `bin/generate.ml` and modify the `Config` structure just like
the section above.

Next, run `dune exec bin/generate.exe > verilog/aoc_solver.v` to generate the
Verilog code.

Create a custom AXI IP and copy the generated `aoc_solver.v`, as well as
`xilinx/aoc_solver_ip_slave_lite_v1_0_S00_AXI.v` into their respective
locations.

Export an `.xsa` file and open it up in Vitis, and create an application with
`main.c` and `main.h`.

Connect to the FPGA to your computer and you'll see the output sent back via
UART.

![](img/fpga.png)

*Day 4 running on my ZedBoard*

## Day 4 Logic

Since Day 4 is basically a rehashed Game of Life (except instead of toggling
cells we kill them if they have `< 4` neighbours), we can approach it like
one.

A 3x3 (binary) convolution window is used to determine the result of the cell
being processed. It's implemented with 3 line buffers, with 3 shift registers
on each buffer.

The core logic is very simple: obtain the centre cell (it's at index 1, 1) and
sum over the values of the 8 remaining cells (its neighbours). If the result is
`< 4` and the centre is occupied (value is `1`), we set the cell to `0`.

A finite state machine is used to keep track of when to stop computation. A
register `has_changed` is set to `vdd` when a value changes and resets at the
end of each cycle (cycle refers to looping through the entire map). The value
of `has_changed` is also used to determine when to stop, as having no changes
across 2 cycles means that the map is in a stable state, and as such the result
should be treated as the final computed answer.

## References

- https://github.com/hrvach/Life_MiSTer
- https://github.com/janestreet/hardcaml_template_project/tree/with-extensions
- https://www.janestreet.com/web-app/hardcaml-docs/
